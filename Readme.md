# Команды Docker. Задание №4

## ***Очистка всех неиспользуемых или не связанных с контейнерами образов, контейнеров, томов и сетей***

В Docker имеется команда, очищающая все не связанные с контейнерами ресурсы, в том числе образы, контейнеры, тома и сети:

```docker
docker system prune
```

Чтобы удалить все остановленные контейнеры и неиспользуемые образы (а не только образы, не связанные с контейнерами), добавьте в эту команду флаг -a:

```docker
docker system prune -a
```

## ***Место, занимаемое докером на хостовой машине***

```docker
docker system df
```

![docker system df](https://habrastorage.org/r/w1560/webt/e5/um/m0/e5umm0ysiuwfrkwqddjhxlfitis.png)

Отображает использование диска Docker’ом в различных разрезах:

1. образы (images) – общий размер образов, которые были скачаны из хранилищ образов и построены в вашей системе;
2. контейнеры (containers) – общий объем дискового пространства, используемый запущенными контейнерами;
3. локальные тома (local volumes) – объем локальных хранилищ, примонтированных к контейнерам;
4. кэш сборки (build cache) – временные файлы, сгенерированные процессом построения образов.

## ***Использование диска образами***

Есть несколько типов образов, которые напрямую не видны конечному пользователю:


1. intermediate образы, на основе которых собраны другие образы в – они не могут быть удалены, если вы используете контейнеры на базе этих самых «других» образов;
2. dangling образы – это такие intermediate образы, на которые не ссылается ни один из запущенных контейнеров – они могут быть удалены.

С помощью следующей команды вы можете проверить наличие в вашей системе dangling образов:

```
docker image ls -f dangling=true

REPOSITORY  TAG      IMAGE ID         CREATED             SIZE
none        none     21e658fe5351     12 minutes ago      71.3MB
```

Удалить их можно следующим способом:

```
docker image rm $(docker image ls -f dangling=true -q)
```

## ***Оптимизация докер контейнеров***

Ниже приведены методы, с помощью которых мы можем добиться оптимизации изображения Docker.

- Использование базовых образов без дистрибутивов с минимальным размером (Alpine-сборки)
- Многоступенчатые сборки
- Минимизация количества слоев
- Рациональное использование кэширования (удаление ненужного кэша)
- Использование файла Dockerignore (копируем только нужные файлы проекта в образ с помощью .dockerignore-файла)
- Хранение данных приложения в другом месте

Многоступенчатые сборки - использование промежуточных изображений (этапы сборки) для компиляции кода, установки зависимостей и упаковки файлов. В этом подходе идея заключается в устранении ненужных слоев в изображении.

Структура папок: 

```
├── Dockerfile1
├── Dockerfile2
├── env
├── index.js
└── package.json
```
Файл ```index.js```:
```
const dotenv=require('dotenv'); 
dotenv.config({ path: './env' });

dotenv.config();

const express=require("express");
const app=express();

app.get('/',(req,res)=>{
  res.send(`Learning to Optimize Docker Images!`);
});


app.listen(process.env.PORT,(err)=>{
    if(err){
        console.log(`Error: ${err.message}`);
    }else{
        console.log(`Listening on port ${process.env.PORT}`);
    }
  }
)
```
Файл ```package.json```:
```
{
  "name": "nodejs",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dotenv": "^10.0.0",
    "express": "^4.17.2"
  }
}
```
Файл ```env```:
```
PORT=8080
```
Файл ```Dockerfile1```:
```
FROM node:16
COPY . .
RUN npm installEXPOSE 3000
CMD [ "node", "index.js" ]
```

После завершения сборки, размер образа будет следующим:
```
docker image ls

node/node-app   1.0       b15397d01cca   22 seconds ago   910MB
```

С помощью метода многоступенчатой сборки попробуем оптимизировать наш образ. Мы будем использовать node:16 для установки зависимостей и модулей, после этого мы переместим содержимое в минимальное и более легкое на основ alpine изображение,которое имеет минимальное кол-во утилит и, следовательно, малый "вес".

Напишем следующее в ```DockerFile2```:
```
FROM node:16 as build

WORKDIR /app
COPY package.json index.js env ./
RUN npm install

FROM node:alpine as main

COPY --from=build /app /
EXPOSE 8080
CMD ["index.js"]
```

Сборка: 
```
docker build -t app/node-app:2.0 --no-cache -f Dockerfile2 .
```

После сборки: 
```
docker image ls

devopscube/node-app   2.0       fa6ae75da252   32 seconds ago   171MB
```

Таким образом размер образа уменьшился с **910Мб** до **171Мб**.

## **Еще команды**:

Статистика используемых ресурсов запущенных контейнеров:
```
docker stats $(docker ps --format {{.Names}}) 
```

Cписок запущенных (работающих контейнеров):
```
docker ps
```

Вывод в режиме реального времени лога событий из контейнера с заданным id:
```
docker logs -f id_container
```

Cписок томов, которые являются предпочитаемым механизмом для сохранения данных, генерируемых и используемых контейнерами Docker:
```
docker volume ls
```

Отобразить процессы в контейнере:
```
docker top container-name
```

Посмотреть историю слоёв образа:
```
docker image history --no-trunc -
```

## **Best Practice**

- Следуй принципу минимальных привилегий, процессы в контейнере никогда не должны выполняться из под рута, кроме редких случаев, нужно добавлять команду user и менять юзера на non-root.
- Не привязываться к UID, он динамичен, можно записать во временную папку UID.
- Сделать все исполняемые файлы владельцем рута, чтобы никто не изменил исполняемые файлы, а пользователю достаточно только права на выполнение.
- Чем меньше компонентов и открытых портов, тем меньше поверхность для атак.
- Использовать multistage для промежуточного контейнера для компиляции всего, зависимостей, временных файлов, образ может весить на треть меньше.
- Distroless с чистого листа, использовать минимальный набор пакетов, например избавиться от образа Ubuntuи выбрать Debian-base, наши контейнеры содержат уязвимости изначального образа.
- Нужно обновлять всё до того, как выйдет из под поддержки.
- Оставлять только те порты, которые реально нужны, избегать 22 и 21 3389 (ssh & ftp & rdp).
- Никогда не помещайте логины/пароли в команде, в докерфайлах, переменных, docker secret или любой другой менеджер секретов ok.
- Не использовать ADD, только COPY (когда используем точку - это воркдир где лежит докерфайл).
- При сборке используйте .dockerignore чтобы убрать сенситив дату, это как .gitignore.
- При сборке вначале команд лучше кешировать команду ран, а потом скопировать исходные данные.
Метадату записать.
- Использовать тесты типа Linter и сканеры образов для CI.
